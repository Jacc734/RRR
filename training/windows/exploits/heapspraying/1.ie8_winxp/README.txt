	[IE8_PRECISE_1]

1. Execute:
	- $ cd "C:\Documents and Settings\Administrator\Desktop\lacon2k14"
	- $ python -m SimpleHTTPServer 8080

2. Open http://127.0.0.1/ie8_precise_1.html and attach to it with WinDBG

3. Search for for unicode string "TEST":
	- $ s -u 0 0x500000 "TEST"
	[*] We can see that chunks are not aligned. Probably because low heap addresses are fragmented
	- $ s -u 0 0x5000000 "TEST"
	[*] We see that chunks located in higher addr are aligned. This is because allocations are new.

What Happens? Our chunks had to be about 0x4000 bytes, but between "TEST" and "TEST" we have chunk 
of sizes greater that that. For example of 0x5000 bytes! (04ff904c - 04ffe04c)
If we check chunk at 04ffe04c we will see that before "TEST" string we have trailing NULLs.

***We have to adjust values to always have the same chunk size***




	[IE8_PRECISE_2]

4. Open http://127.0.0.1/ie8_precise_2.html and attach to it with WinDBG
	[*] We only changed large chunks from 0x7000 to 0x8000

5. Search for for unicode string "TEST":
	-  s -u 0 5000000 "TEST"
	[*] We can see that all chunks have the same size 0x4000

6. Time to calculate the correct offset. Check the address you want to jump to, from which chunk is it?
	- !heap -p -a 08080808
	- ?08080808 - <usr_ptr>
	[*] We have to substract 4 from the address to take in account the BSTR header that the substring will add.
	[*] We'll have to divide the offset by 2 because the substring works in unicode!



	[IE8_PRECISE_3]

7. Open http://127.0.0.1/ie8_precise_2.html and attach to it with WinDBG

8. Show memory in 0x08080808 and check that the start of the ROP chain is there!


	[XPL]

9. Show the exploit and open it with the browser! Own3d!
