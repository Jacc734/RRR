<!DOCTYPE HTML>

<html>
<head>
	<meta charset="utf-8">
	<!-- Include required JS files -->
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/shCore.js"></script>
	<!-- At least one brush -->
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/langs/shBrushPython.js"></script>
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/langs/shBrushNasm8086.js"></script>
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/langs/shBrushCpp.js"></script>
	<!-- Include *at least* the core style and default theme -->
	<link href="../template/syntaxhighlighter_3.0.83/css/shCore.css" rel="stylesheet" type="text/css" />
	<link href="../template/syntaxhighlighter_3.0.83/css/shThemeDefault.css" rel="stylesheet" type="text/css" />
	<!-- My styles -->
	<link href="../template/css/my_styles.css" rel="stylesheet" type="text/css" />
</head>

<body>

<h1>LAB 5-1</h1>
<h3>Analyze the malware found in the file Lab05-01.dll using only IDA Pro. As a bonus, we'll also use Radare2!</h3>

<div class="question-container">
	<div class="question">1. What is the address of DLLMain?</div>
	<div class="answer">
        With IDA Pro, once you open the DLL you are pointed directly to DLLMain. To know the address you can go to "Options" --> "General" and check "Line Prefixes". This will show that DllMain function is located at 0x1000D02E.<br>
        <br>
        <img class="centered_img" src="img/5-1.1.1.png"/>
        <br>
        There are other ways to find it using IDA Pro. You can also search the symbol using the option "Search" --> "text" and writing DllMain. It might not land in the function definition but you can double-click the symbol to go the the definition. <br>
        Another option is going to the Function Window at "Windows" --> "Functions window" (or Alt+1) and scroll until you find DllMain.<br>
        <br>
        <br>
        With r2 it seems that the symbol is not found. You can list all functions using the command "afl" once the binary is opened with "$r2 Lab05-01.dll". To grep you can use "afl~Main", but as can be seen, the DllMain function is not listed:<br>
        <br>
        <img class="centered_img" src="img/5-1.1.2.png"/>
        <br>
        We can see that in the DllMain address (from r2 prompt "$r2 Lab03-01.dll" seek offset as "s 0x1000D02E" and enter in Visual mode "V"), r2 tells us that the symbol is called sub.MSVCRT.dll_strncpy_2e, so it doesn't correctly detect the symbol:<br>
        <br>
        <img class="centered_img" src="img/5-1.1.3.png"/>
        <br>
        Nevertheless, the disassembled code is the same as in IDA Pro.
	</div>
</div>

<div class="question-container">
    <div class="question">2. Use the Imports window to browse to gethostbyname. Where is the import located?</div>
	<div class="answer">
        With IDA you'll have to open the Imports window going to "View" --> "Open Subviews" --> "Imports" and search gethostbyname:            
        <br>
        <img class="centered_img" src="img/5-1.2.1.png"/>
        <br>
        The address is 0x100163CC.<br>
        <br>
        <br>
        On the other hand, r2 doesn't get the name of the function nor its address. You can use "rabin2 -i Lab03-01.dll" and all imported functions will be shown.<br>
        <br>
        <img class="centered_img" src="img/5-1.2.2.png"/>
        <br>
        The ordinal value of the gethostbyname function is 52 and it's from WS2_32.dll. As can be seen, it's listed by ordinal not by function name. Moreover, the address is not shown.<br>
        You can also try to look for functions with r2, but this specific function is not listed:<br>
        <br>
        <img class="centered_img" src="img/5-1.2.3.png"/>
        <br>
        <p class="red">Good answer:</p>
        It seems that the function is not listed because it is relocated. With r2 we can list all relocations using the "ir" command, as shown:<br>
        <br>
        <img class="centered_img" src="img/5-1.2.4.png"/>
        <br>
        We can see that the address of Ordinal52 is the same as the one shown with IDA Pro: 0x100163CC.
	</div>
</div>

<div class="question-container">
	<div class="question">3. How many functions call gethostbyname?</div>
	<div class="answer">
        With IDA Pro, to know that you only have to double-click in the function name of the imports window and that will lead you to the function declaration of the gethostbyname function. Once there you can click 'x' and a window with the cross-references (xrefs) will be shown:<br>
        <br>
        <img class="centered_img" src="img/5-1.3.1.png"/>
        <br>
        <strike>As can be seen, there are 18 calls to gethostbyname.</strike><br>
        <br>
        There are 9 calls to gethostbyname. The items with a "p" (pointer reference) Type (second column) are the references that mean that the function will be called. The items with the "r" (read references) mean that the address will be read. In this case, the "p" and "r" addresses are the same because the gethostbyname function is imported and will be readed too before executed. This explanation is a bit confusing, what matters is that one has to track the xrefs as "p" when want to know how many times a function is called.<br>
        The function is called from 5 different functions. 
        <br>
        <br>
        <strike>With r2, I couldn't find a way to do this because the function is not even listed.</strike><br>
        <p class="red">Good answer:</p>Now that we know the address of the gethostbyname function, the normal step would be to analyze the binary with "aa", seek the function address by "s 0x100163CC", then change to Visual Mode with "V" and [Enter] and finally typing "x" would show all references to that functions. <br>
        In this case, this doesn't work, maybe because relocation issues or because "aa" doesn't analyze all binary. So another strategy is to use the search functionality. Using the command "/" (not in Visual Mode) we can make searches. We'll use /a to assemble an assembly instruction and search its bytes. <br>
        So the command would be like this: "/a call dword [0x100163CC]" or "/a call [0x100163CC]". It's important to use the address and not the symbol name. The results are shown below: <br>
        <br>
        <img class="centered_img" src="img/5-1.3.2.png"/>
        <br>
        As can be seen, there are xrefs that are not shown. This might be some kind of bug in the search engine. Only 7 references have been found instead of 9.
    </div>
</div>

<div class="question-container">
	<div class="question">4. Focusing on the call to gethostbyname located at 0x10001757, can you figure out which DNS request will be made?</div>
	<div class="answer">
        The DNS request will be made to pics.practicalmalwareanalysis.com. <br>
        <br>
        With IDA Pro we can find that out going to the address 0x10001757 by pressing G and writing the address or by going to "Jump" --> "Address" and writing the address.<br>
        We can see the following code:<br>
        <br>
        <img class="centered_img" src="img/5-1.4.1.png"/>
        <br>
        The first parameter to gethostbyname is stored in EAX. In EAX it's stored the address of off_10019040 and then 0xD is added to that address. In the address in which off_10019040 is pointing we have a pointer to our string, so we double-click again the aThisIsRdoPics_ variable and we'll jump directly to the declaration of the string "[This is RDO]pics.praticalmalwareanalysis.com". If we add 0xD to the address of this string we finally get the domain name used by gethostbyname().<br>
        <br>
        <br>
        Using r2 we can move to the address using "s 0x10001757" and then we can activate Visual Mode typing "V" and [Enter]. Then "p" to go to the disassembly view.<br>
        <br>
        <img class="centered_img" src="img/5-1.4.2.png"/>
        <br>
        We can see that the disassembled code is the same, although offsets are no named but the virtual address is used:<br>
        <br>
        <img class="centered_img" src="img/5-1.4.3.png"/>
        <br>
        So the next step would be to look at the address stored in 0x10019040. For that, still in Visual Mode we can type ":" and "s 0x10019040" and [Enter].<br>
        We can see that we jump there, but the content is shown as assembly. We want the address stored in 0x10019040, so we change from Visual Mode to Hex Mode by clicking "p" a few times.<br>
        <br>
        <img class="centered_img" src="img/5-1.4.4.png"/>
        <br>
        As can be seen, the address stored there is 0x10019194. This address points to the beginning of the string as can be seen in the same image, but if we wanted to jump there we would have to repeat the process of ":", "s address" and [Enter].<br>
        <br>
        <img class="centered_img" src="img/5-1.4.5.png"/>
        <br>
        We could now click the "l" key (0xD times) to "move left", incrementing the first address of the hex dump to go to the start of the string 0x10019194+0xD.<br>
        <br>
        <img class="centered_img" src="img/5-1.4.6.png"/>
        <br>

	</div>
</div>

<div class="question-container">
	<div class="question">5. How many local variables has Ida Pro recognized for the subroutine at 0x10001656?</div>
	<div class="answer">
        With IDA Pro, you can see that in each function definition, the local variables and function parameters are identified as what they are by its name. For example, variable names normally start with "var_" and function parameters/arguments with "arg_". <br>
        Sometimes the name of these varaibles/parameters are identified as Windows API function parameters, so they took the name listed in the API documentation. So we'll have variables called, for example, hLibModule, timeout, etc. These names don't have the "var_" or "arg_" prefix so we have another way to distinguish variables from function parameters.<br>
        We can see that the names of the vars and params are associated with a certain offset (+4, -4, -8, and so on). Usually, the offsets with the same sign pertain as the same group (variables or parameters). In this particular case, all names associated with a negative offset are variables and all names associated with a positive offset are parameters. <br>
        <br>
        We have 23 local variables and 1 function arguments. <br>
        <br>
        <img class="centered_img" src="img/5-1.5.1.png"/>
        <br>
        These offsets are used as a reference from register ESP or EBP. Normally, using a negative offset from EBP would mean that we are working with parameters and using a positive offset would mean that we are working with local variables. It will depend on the compiler used to generate the binary. In this case we can see that those offsets are always used from ESP. It's easy to undertand how to access local variables from ESP with a negative offset, as is done in this example, but accessing functions parameters with a positive offset from ESP is weird. It might mean that the Parameter Shadowing protection from the /GS compile flag is in use and what it does is that copies parameters below local variables in the stack (as opposed as in the normal behavior of stack frames).<br>
        <br>
        <img class="centered_img" src="img/5-1.5.2.png"/>
        <br>
        <br>
        <br>
        Radare2 does not have a feature to identify parameters or variables. It uses the raw offsets instead of replacing them with names:<br>
        <br>
        <img class="centered_img" src="img/5-1.5.3.png"/>
        <br>
	</div>
</div>

<div class="question-container">
	<div class="question">6. How many parameters has IDA Pro recognized for the subroutine at 0x10001656?</div>
	<div class="answer">
        The answer is in the previous question.
	</div>
</div>

<div class="question-container">
	<div class="question">7. Use the Strings window to locate the string \cmd.exe /c in the disassembly. Where is it located?</div>
	<div class="answer">
        With IDA Pro you can look at the Strings Windows going to "View" --> "Open subview" --> "Strings" or clicking "Shift+F12". Then it's useful to order by String (alphabetically) so the string is easier to find:<br>
        <br>
        <img class="centered_img" src="img/5-1.7.1.png"/>
        <br>
        The string is located at address 0x10095B34.
        <br>
        <br>
        With r2 framework you can use the rabin2 tool. For searching strings you have the -z flag, that will search strings in the .data section. The problem is that this string is not in the .data section, so it won't appear. Nevertheless, you can use the -zz flag to search through all the binary (or search strings from raw bins, as told in the manpage)<br>
        <br>
        <br>
        <img class="centered_img" src="img/5-1.7.2.png"/>
        <br>
        We can see that the address is the same.<br>
        <br>
        You can also use r2 and the "i" command from the console.<br>
        <br>
        <img class="centered_img" src="img/5-1.7.3.png"/>
        <br>
	</div>
</div>

<div class="question-container">
	<div class="question">8. What is happening in the area of code that references \cmd.exe /c?</div>
	<div class="answer">
        With Ida Pro you have to look at the xrefs for the string address. You can double click the string shown in the image in the previous question and you'll be moved to a normal assembler view. Press 'x' in the address of the string and double click the xref shown. You'll be pointed to the code that works with the string:<br>    
        <br>
        <img class="centered_img" src="img/5-1.8.1.png"/>
        <br>
        You can move the graph view to look at the function code. If you go to the function definition you can see a welcome message like "Hi, master": <br>
        <br>
        <img class="centered_img" src="img/5-1.8.2.png"/>
        <br>
        Then, if you go down to addresses 100102C7, 100102E5, 10010302, 100104DF, 1001050C, you can find the strings quit, exit, cd, mininstall, inject, respectively and these strings are compared with memcmp. Added to the fact that cmd.exe or a command.exe is executed, it seems that a shell is built and those strings are the available commands. You could also infer that this is a remote shell because in 1001020B the recv function is used, so it all points that the commands are received remotely with the recv function and compared with the list of available commands.<br>
        <br>
        <br>
        With r2 you can seek to the address of the string ("s 0x10095B34" from r2 console) and look to their xrefs. For doing that, once you've seeked to the string address, you'll have to enter in visual mode by executing "V" in the r2 console. Then, in the first view (Hexadecimal View) you'll have to press "c" to go into "cursor mode". Then you'll have to press the 'x' key and the xrefs will be shown as a list with numbers as a reference. If you want to go to any xref address you'll have to click the number of that xref, in our case "0":<br>
        <br>
        <img class="centered_img" src="img/5-1.8.3.png"/>
        <br>
        <img class="centered_img" src="img/5-1.8.4.png"/>
        <br>
        After click "0" to go to the xref, you'll have to press "p" to go into disassembly view:<br>
        <br>
        <img class="centered_img" src="img/5-1.8.5.png"/>
        <br>
        If you move a bit the disassembly view of r2 you can see that the disassembly is the same as in IDA Pro in text mode:<br>
        <br>
        <img class="centered_img" src="img/5-1.8.6.png"/>
        <br>
        So you'll have to analyze the disassembly as with IDA Pro.<br>
        With r2 you also have an awesome ascii graph view. You can check it by clicking "V" again in Visual Mode. It's not polished and have some problems, so we'll leave it for the moment.
	</div>
</div>

<div class="question-container">
	<div class="question">9. In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword_1008E5C4? (Hint: Use dword_1008E5C4 cross-references)</div>
	<div class="answer">
        With IDA Pro you can go to address 0x100101C8 and start going backwards using xrefs to know at which point the dword_1008E5C$ value is set.<br>
        So first, press G to go to 0x100101C8:<br>
        <br>
        <img class="centered_img" src="img/5-1.9.1.png"/>
        <br>
        Then click "x" with the cursor in the yellow "dword_1008E5C4" and you'll see all the places in which this variable is referenced:<br>
        <br>
        <img class="centered_img" src="img/5-1.9.2.png"/>
        <br>
        We can see that there are only one xref that sets the value of this variable. This is the first reference with the "mov dword_1008E5C4, eax" instruction. So we go to that code address by double clicking the item in the list:<br>
        <br>
        <img class="centered_img" src="img/5-1.9.3.png"/>
        <br>
        As can be seen, before this instruction we have a call to a function. In x86 the result of a function call is stored in the EAX register, so we will have to further investigate the sub_10003695 function to know what is stored in EAX and finally in dword_1008E5C4. Double click the name of the function "sub_10003695":<br>
        <br>
        <img class="centered_img" src="img/5-1.9.4.png"/>
        <br>
        The function is small.<br>
        Taking a fast look we can deduce that this function makes some kind of detection of which OS version is running. There's a call to GetVersionEx function. The result of this function is stored in the same address in which its parameter is located, for these reason after the call to this function the value of the EAX register is not used. We can find know the behaviour of this function looking at its <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724451(v=vs.85).aspx">documentation</a>.  In the end it compares the value in the address of EBP+VersionInformation.dwPlatformId with 2. The contents of the EBP+VersionInformation address is setted by the call to GetVersionEx. If it's equal to 2, eax is is set to 1 (the least significant byte).<br>
        If we search on the Windows documentation what the dwPlatformID is we can find the following:<br>
        <br>
        <img class="centered_img" src="img/5-1.9.5.png"/>
        <br>
        As we can see, it's checked if the operating system is any of those Windows versions, if not, EAX is 0.<br><br>
        So the code path taken would depend on the version of windows in which the malware is being executed.
        <br>
        <br>
        With r2 we will have to make the same analysis. First we'll have to open the DLL with r2, seek to 0x100101C8 and before going to Visual Mode, analyze all functions with "aa":<br>
        <br>
        <img class="centered_img" src="img/5-1.9.6.png"/>
        <br>
        Here we don't have variables named but the address itself, so we have to check the xrefs of the 0x1008E5C4 that is the address used in the "cmp" instruction. We cannot use the 'x' key or the "/a <instruction>" in this context, because we only want to find xrefs to the 0x1008E5C4 address, to know how it's setted. <br>
        <br>
        Therefore we will have to use another strategy. We want to know where this address has been used in the code. What we can do is simply search for this address with the "/v" command as shown below:<br> 
        <br>
        <img class="centered_img" src="img/5-1.9.7.png"/>
        <br>
        If we look at the first hit instructions with "pd 10@hit0_0" we have the following instructions:<br>
        <br>
        <img class="centered_img" src="img/5-1.9.8.png"/>
        <br>
        We can see that the first instruction is invalid. This is caused because the search (or the hit) is just in the start of the first byte (in little endian) of our search (0xC4), but the bytes C4E50810 are not a valid instruction, so we have to go back from hit0_0 to correctly disassemble the instructions:<br>
        <br>
        <img class="centered_img" src="img/5-1.9.9.png"/>
        <br>
        To analyze the function in which this instruction is executed, seek to hit0_0-1 with "s hit0_0-1" and go to Visual Mode (V). If you go a little up from the hit0_0-1 with the "k" key you will see that the EAX value comes from a function call "call fcn.10003695":<br>
        <br>
        <img class="centered_img" src="img/5-1.9.10.png"/>
        <br>
        If you click "1" you will go to that function:<br>
        <br>
        <img class="centered_img" src="img/5-1.9.8.png"/>
        <br>
        There you have the same function as with IDA Pro, the real problem with r2 as it is now is that you don't have named variables and you will have to know that with the "cmp dword [ebp-0x84], 0x2", the -0x84 offset is to access the dwPlatformId field of the OSVERSIONINFO structure. That was really intuitive and fast with IDA Pro but it's a time consuming task with r2.<br>
        <br>
        But in the end we'd come to the same conclusion.
	</div>
</div>

<div class="question-container">
	<div class="question">10. A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?</div>
	<div class="answer">
        With IDA Pro we use the "G" key to go to the 0x1000FF58 address. Then we go down until we find the code that references the "robotwork" and the memcmp (address 0x10010444).<br>
        <br>
        <img class="centered_img" src="img/5-1.10.1.png"/>
        <br>
        We have to follow the red line (the jnz condition has not been fulfilled). Double click the red line:<br>
        <br>
        <img class="centered_img" src="img/5-1.10.2.png"/>
        <br>
        The important thing here is the call to the sub_100052A2 function, so we double click its name:<br>
        <br>
        <img class="centered_img" src="img/5-1.10.3.png"/>
        <br>
        Here we have a bigger function. We have to read the assembly of all the function to understand whats it's doing. To take a quick look you have to look which functions are being called and with which parameters. For example we can see that the RegOpenKeyExA function is called with the 'SOFTWARE\Microsoft\Windows\CurrentVersion' string. If the function doesn't succeed, the code flows goes almost to the end of the function and closes the key with the RegCloseKey function. If the RegOpenKeyExA succeeds, there are a few calls to RegQueryValueExA and sprintf and atoi, and finally also closing the key with the RegCloseKey function.<br>
        <br>
        More precisely, once opened the mentioned key, a call to RegQueryValue is done with the lpValueName ([ebp+Str] address) set to 0 (previously we had an "and [ebp+Str], 0") and next another call is done to RegQueryValue with lpValueName as "WorkTime" and then it's checked if the return value of this call is 0 ("test eax, eax" sets flag [Z]ero if the AND with EAX and EAX is zero, what means that eax equal 0), to know if the function call has succeed. <br>
        <br>
        <img class="centered_img" src="img/5-1.10.4.png"/>
        <br>
        If the function does not succeed (returns anything but 0), the same process is done but this time using the lpValueName "WorkTimes".<br>
        If both calls fail, the key is closed and the function ends, but if any of the two calls works, the function sub_100038EE is called. Before doing that call, sprintf and atoi are called with the string "[Robot_WorkTime :] %d". The %d will probably be the value returned by the RegQueryValue function.<br>
        <br>
        So the sub_100038EE function looks like this:<br>
        <br>
        <img class="centered_img" src="img/5-1.10.5.png"/>
        <br>
        We can see that in this function first a malloc is done and then the argument past to the function is sent to the internet (at least using a socket) using the function send().<br>
        <br>
        <img class="centered_img" src="img/5-1.10.6.png"/>
        <br>
        To understand what is sent through the socket, we'll have to analyze what happens before the function that sends it is called:<br>
        <br>
        <img class="centered_img" src="img/5-1.10.7.png"/>
        <br>
        In sub_100038EE function definition we have seen the following signature "sub_100038EE(SOCKET s, int, int len)". In fact, the second argument is the address in which the data that will be sent resides. The first argument is a socket and the last one is the length of the data to be sent.<br>
        So once we have this information is much more easy to understand what happens in the previous figure before calling the function. Just before the call we have a "push [ebp+s]", this is the value of the socket, before that there is a "push eax". In EAX we have the address of EBP+Dest, setted with the "lea eax, [ebp+Dest]". This is the address in where the data to be sent resides (the "[Robot_WorkTime :] %d"), finally we have another "push eax" that stores the value returned by strlen() function, that computes the length of the string sent. End.<br>
        <br>
        <br>
        Let's do the same with r2. Remember doing an "aa" before anything else once you open the binary.<br>
        We will go a little faster here, using some easy to retrieve information that we got with IDA Pro. For example, we directly go to address 0x10010444 (where the "robotwork" string is compared) using "s 0x10010444":<br>
        <br>
        <img class="centered_img" src="img/5-1.10.8.png"/>
        <br>
        As we can see, the disassembled code is the same but we don't have the useful help to know what's in each offset or address, so we would have to look what's in the pushed address that is memcmpared. We'll click ":" and then type "s 0x10095acc", [Enter] and [Enter]. Then you will see how the disassembly is changed, you've been moved to address 0x10095acc, now you have to change to Hexadecimal View to check if there's an string there. So click "p" until getting that view:<br>
        <br>
        <img class="centered_img" src="img/5-1.10.9.png"/>
        <br>
        There we have our "robotwork" string. So everything goes fine. If we click "u" we'll move to the previous seek point (in r2 "u" is like [Esc] in IDA Pro). Once you click "u", change the view with "p" to return to the Disassembly View.<br>
        Analyzing the code, it's easy to understand that if the comparison is correct, the call to 0x100052a2 will be executed. So we click "3" to go to the function definition.<br>
        <br>
        <img class="centered_img" src="img/5-1.10.10.png"/>
        <br>
        In the previous image, we can see the calls to RegOpenKey, RegCloseKey, RegQueryValue and sprintf. A good strategy to understand what is happening in a function would be to look at all the "call"s that are done from within it. Let's try that.<br>
        We'll search "call" instructions in the address range within this function. So the start address would be 0x100052a2 and if we move ourself through the code with the h,j,k,l keys we'll see that the end of the function is at 0x100053f8. So we click leave the Disassembly View with "q" to get to the console.<br>
        If we get the help ("?") for the search command ("/") with "/?" we will see two useful options: search.from and search.to. We set this options and use the /c <inst> to search:<br>
        <br>
        <img class="centered_img" src="img/5-1.10.11.png"/>
        <br>
        It seems that the trick has not worked as expected because the addresses of the calls are not resolved as in the Disassembly View. We would have to look at each address of the issued calls using, for example, "pd 2@<addr>". "pd" is the acronym for print disassembly.<br>
        <br>
        <img class="centered_img" src="img/5-1.10.12.png"/>
        <br>
        We can see that it works, although it's slow to do. Now we would have to start manually looking at each address as we have done previously with the "robotwork" string to know which key is opened, what is sprintf'ed and so on. With a little more work, we would get to the same conclusion as with IDA Pro.
	</div>
</div>

<div class="question-container">
	<div class="question">11. What does the export PSLIST do?</div>
	<div class="answer">
        With IDA Pro we go to the Exports Window, "View" --> "Open subview" --> "Exports" and double click the PSLIST item in the list. This will take us to the function disassembly at address 0x10007025:<br>    
        <br>
        <img class="centered_img" src="img/5-1.11.1.png"/>
        <br>
        The first insteresting thing it does is calling the function sub_100036C3, so we'll analyze it by double clicking on its name:<br> 
        <br>
        <img class="centered_img" src="img/5-1.11.2.png"/>
        <br>
        The function calls GetVersion function and checks if the dwPlatformId is 2, if so it returns 1, if not it checks the dwMajorVersion output, if it's less than 5 it returns 1 and if not it returns 0. To sum up, it checks if operating system version is greater or equal to Windows 2000.<br>
        <br>
        <img class="centered_img" src="img/5-1.11.3.png"/>
        <br>
        Then, if the function returns 0 there's a check for the length of the Str parameter. Given that this is an Export, there's no any piece of code that is calling this function so we can't know what this parameter will be using xrefs. Depending on the length of this Str, the code calls function sub_10006518 (if length=0) or sub_1000664C (if length!=0). We'll have to analyze both.<br>
        Taking a fast look to the sub_1000664C function, it seems that makes a snapshot of the system and sends information through the internet of the processes running on it. You can infer that because of the calls to CreateToolHelp32Snapshot, Process32First, Process32Next and sub_100038BB that's a wrapper for send(). In fact, it only sends information about one process whose name has been identified as a parameter. We can see that in the following code:<br>
        <br>
        <img class="centered_img" src="img/5-1.11.4.png"/>
        <br>
        If the strcmp fails, the process is not analyzed and the code looks at the next process in the process list.<br>
        The function sub_10006518, does exactly the same as the previous one but instead of only sending information of a process it sends information about all the processes. So, finally, we are able to deduce what's the Str parameter. A string identifying a process. If it's not passed to the exported function, the functions sends information about all processes, if it's passed, it sends information about only that process.<br>
        <br>
        <br>
        With r2, first we have to list the exports. In order to do that, we will list the symbols of the DLL with the "is" command. "i" for information and "s" for symbols:<br>
        <br>
        <img class="centered_img" src="img/5-1.11.5.png"/>
        <br>
        This way we get that the export would be located in 0x00007025 address. But that's the address without the offset once mapped to memory, so we would have to get the image base address using the "ie" command:<br>
        <br>
        <img class="centered_img" src="img/5-1.11.6.png"/>
        <br>
        If we look at the baddr (base address) we can see it's 0x10000000, so the PLIST would be mapped at 0x10007025. So if we seek to that address and go to Visual Mode, the code is the same as with IDA Pro:<br>
        <br>
        <img class="centered_img" src="img/5-1.11.7.png"/>
        <br>
        We would have to analyze functions [1], [5] and [7] to get to the same conclusion as in the previous analysis. Going to [7] (clicking "7") we can see that API calls are resolved, so our analysis would use the same methodology as the previous.
	</div> 
</div>

<div class="question-container">
	<div class="question">12. Use the graph mode to graph the cross-reference from sub_10004E79. Which API functions could be called by entering this function? Based on the API functions alone, what could you rename this function?</div>
	<div class="answer">
        In IDA Pro, first go to 0x10004E79 using the "G" key. Then you can show xrefs from a function clicking on the function name and going to "View" --> "Graphs" --> "Xrefs from":<br>  
        <br>
        <img class="centered_img" src="img/5-1.12.1.png"/>
        <br>
        There's only one API function call, to GetSystemDefaultLangID, so an appropiate name for the function, knowing only that, would be "get_os_lang". If we take in account the send() function, we might call this function "send_os_lang".<br>
        <br>
        <br>
        With r2 you are able to do the same using the command "agc" as can be seen in the r2 help:<br>
        <br>
        <img class="centered_img" src="img/5-1.12.2.png"/>
        <br>
        This commands should be executed as follows:<br>
        <ul style="list-style-type:none">
            <li>agc 0x10004E79 > graph.dot</li>
            <li>!dot -Tpng graph.dot > graph.png</li>
        </ul>
        To execute dot, you have to install the xdot tool: sudo apt-get install xdot.<br>
        <br>
        You will get the following graph:<br>
        <br>
        <img class="centered_img" src="img/5-1.12.3.png"/>
        <br>
        Right now, there's no option to set the depth of the call graphs, so we can only see a call graph of depth=1. Nevertheless the r2 creator (aka, pancake) just opened an <a href="https://github.com/radare/radare2/issues/1642">issue</a> to solve this. Thanks for that! :)<br>
        <br>
        There's another awesome way to generate graphs. Graphs can be shown as ascii. You have to seek to the function to graph (s 0x10004E79), then click V, [Enter] and once in Visual Mode, click VV. The first "V" will show the function as a graph and the second "V" is for showing a graph of the calls in the function.<br>
        In this view you can use a,d,w,s to move the portrait and h,j,k,l to mode the node in which you are. By clicking [Tab] you will be able to move from a node to another. After moving nodes a little bit, you'd be able to get something like this:<br>
        <br>
        <img class="centered_img" src="img/5-1.12.4.png"/>
        <br>
        Right now, graphs don't get relocation function names, but, as always, an <a href="https://github.com/radare/radare2/issues/1643">issue</a> is fastly opened once r2 team is contacted! Thank you, pancake!
	</div>
</div>

<div class="question-container">
	<div class="question">13. How many windows API functions does DLLMain call directly? How many at a depth of 2?</div>
	<div class="answer">
        To know that using IDA Pro, we can use some options to configure graph output. In order to do that, first we put the cursor in the address or name definition of DllMain (you can find it in the "functions window") and then we should go to "View" --> "Graphs" --> "User xrefs chart...". We'll see a bunch of options and we have to check them as in the following image:<br>  
        <br>
        <img class="centered_img" src="img/5-1.13.1.png"/>
        <br>
        Then you'll get something like this:<br>
        <br>
        <img class="centered_img" src="img/5-1.13.2.png"/>
        <br>
        If you want to see calls from functions called from DllMain, you only have to change depth to 2:<br>
        <br>
        <img class="centered_img" src="img/5-1.13.3.png"/>
        <br>
        You can see in the footer of the window that it's said that there are 99 nodes, so this means that from DllMain 98 calls are made using depth 2.<br>
        <br>
        <br>
        With r2, right now, there's no option to set the depth of the call graphs, so we can only see a call graph of depth=1. Nevertheless the r2 main developer (aka, pancake) just opened an <a href="https://github.com/radare/radare2/issues/1642">issue</a> to solve this. Thanks for that! :)<br>
	</div>
</div>

<div class="question-container">
	<div class="question">14. At 0x10001358, there is a call to Sleep (an API function that takes one parameter containing the number if milliseconds to sleep). Looking backward through the code, how long will the program sleep if this code executes?</div>
	<div class="answer">
        With IDA Pro we go to 0x10001358 using "G". There we can see that the function that makes all the work is the following:<br> 
        <br>
        <img class="centered_img" src="img/5-1.14.1.png"/>
        <br>
        At off_10019020 we have the string "[This is CTI]30". The address pointing to this string is stored in EAX and then 0xD is added, to now EAX points to "30". Then atoi() is called with the parameter pointing to that "30", so we get an integer from the "30" string. Then this 30 is multiplied by 0x3E8 (1000 in decimal), getting 30000 in decimal. And finally Sleep() is called using this value as parameter, so the program will wait for 30 seconds.<br>
        <br>
        <br>
        With r2 we can do the same. If you don't want to always execute the "aa" command once opening r2, you can load the binary with:<br>
        <ul style="list-style-type:none">
            <li>r2 -A Lab05-01.dll</li>
        </ul>
        Then seek to 0x10001358. We have the same:<br>
        <br>
        <img class="centered_img" src="img/5-1.14.2.png"/>
        <br>
        If we look at what's stored in EAX by printing what's in that address in string format we got the following:<br>
        <br>
        <img class="centered_img" src="img/5-1.14.3.png"/>
        <br>
        We can see from the disassembly image that in address 0x10019020 we have the address 0x100192AC. The instruction "mov eax, [0x10019020]" puts in EAX what's in the address 0x10019020, and as we've said in this address we have 0x100192AC, that as shown in the previous image points to the "[This is CTI]30" string.<br>
        In the previous image, we have clicked to ":" in the Disassembly View and have executed the ps ([p]rint null-terminated [s]tring in address 0x100192AC) command to see if in 0x100192AC we had an string.
	</div>
</div>

<div class="question-container">
	<div class="question">15. At 0x10001701 is a call to socket. What are the three parameters?</div>
	<div class="answer">
        Going to that address with IDA Pro we can see the following code:<br>
        <br>
        <img class="centered_img" src="img/5-1.15.1.png"/>
        <br>
        Knowing the calling convention we can know that the socket function will be called as socket(2,1,6). If we look at the function definition by double clicking the socket string we get that its definition is socket(int af, int type, int protocol).<br>
        <br>
        <br>
        With r2, the socket function is not shown by its name but by its ordinal:<br>
        <br>
        <img class="centered_img" src="img/5-1.15.2.png"/>
        <br>
        You can know ordinal represents each function using tools as Dependency Walker, but as far as I know, r2 doesn't have any tool to know that.
	</div>
</div>

<div class="question-container">
	<div class="question">16. Using the MSDN page for socket and the named symbolic constants functionality in IDA Pro, can you make the parameters more meaningful? What are the parameters after you apply the changes?</div>
	<div class="answer">
        Going to the MSDN page for <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms740506(v=vs.85).aspx">socket</a>, we can see which value is related to which constant name, so we have that the 6 in protocol parameter is for IPPROTO_TCP, the 1 in type parameter is for SOCK_STREAM and 2 in af parameter is for AF_INET.<br>
        
        With IDA Pro we can right-click in each of this numbers and select "Symbolic constant" --> "Use standard symbolic constant" and choose the appropiate name for the values from a list with all constant names with the same value as the number you have right-clicked:<br>

        <br>
        <img class="centered_img" src="img/5-1.16.1.png"/>
        <br>
        In the end we'll have something like this:<br>
        <br>
        <img class="centered_img" src="img/5-1.16.2.png"/>
        <br>
        <br>
        <br>
        As far as I know, r2 doesn't let you choose among these constants. Nevertheless, we can add comments in addresses and this will have a similar behaviour as what we did with IDA Pro. As with IDA we'll have to know what does each constant means in the socket context, so we will have to also use the MSDN documentation, but we won't be able to choose among a list of constants so we'll have to directly write the constant name as a command. We can achieve this with the "CCa" command:<br>
        <br>
        <img class="centered_img" src="img/5-1.16.3.png"/>
        <br>
        In the end, we'll have something similar to this:<br>
        <br>
        <img class="centered_img" src="img/5-1.16.4.png"/>
        <br>
	</div>
</div>

<div class="question-container">
	<div class="question">17. Search for usage of the "in" instruction (opcode 0xED). This instruction is used with a magic string VMXh to perform VMware detection. Is that in use in this malware? Using the cross-reference to the function that executes the in instruction, is there further evidence of VMware detection?</div>
	<div class="answer">
        With IDA Pro, you can go to "Search" --> "text..." and in the new window write the instruction to search ("in") and check "Find all ocurrences":<br>
        <br>
        <img class="centered_img" src="img/5-1.17.1.png"/>
        <br>
        Then you will get the following results:<br>
        <br>
        <img class="centered_img" src="img/5-1.17.2.png"/>
        <br>
        If we go to that address we can see the code:<br>
        <br>
        <img class="centered_img" src="img/5-1.17.3.png"/>
        <br>
        Now we would have to analyze the xrefs from the functions in which this instruction is used: sub_10006196. To do so, we go to address ("G") 0x10006196 and press "x". <br>
        <br>
        <img class="centered_img" src="img/5-1.17.4.png"/>
        <br>
        It can be seen that this function is called from three different locations, basically, once this DLL is installed. Going to the first reference, we can see that after the call is executed, depending on what is returned, we have an string saying that a virtual machine has been detected and that the installation is being cancelled.<br>
        <br>
        <img class="centered_img" src="img/5-1.17.5.png"/>
        <br>
        <br>
        More information about this technique can be found <a href="http://www.codeproject.com/Articles/9823/Detect-if-your-program-is-running-inside-a-Virtual">here</a>.<br>
        <br>
        <br>
        With r2, you can search for instructions using the "/c" command, so we'd use "/c in". Using that, there are too many results, so we'll have to restrict the search a little bit. Knowing how the VM detection goes, you know that we need the following instruction "in eax, dx" so we'll search for that:<br>
        <br>
        <img class="centered_img" src="img/5-1.17.6.png"/>
        <br>
        It seems that r2 is not capable of finding the correct instruction. <br>
        Using the information retrieved with IDA Pro, if we go to address 0x100061D8 we can find the correct instruction, so it's weird that the search didn't find it:<br>
        <br>
        <img class="centered_img" src="img/5-1.17.7.png"/>
        <br>
	</div>
</div>

<div class="question-container">
	<div class="question">18. Jump your cursor to 0x1001D988, What do you find?</div>
	<div class="answer">
        Doing that with IDA Pro we find the following:<br> 
        <br>
        <img class="centered_img" src="img/5-1.18.1.png"/>
        <br>
        It seems a bunch of ascii characters without any sense. <br>
        <br>
        <br>
        With r2 we got the same (easy to see in Hexadecimal View).<br>
        <br>
        <img class="centered_img" src="img/5-1.18.2.png"/>
        <br>
	</div>
</div>

<div class="question-container">
	<div class="question">19. If you have the IDA Python plugin installed (included with the comercial version of IDA Pro), run Lab05-01.py, an IDA Pro python script provided with the malware for this book. (Make sure the cursor is at 0x1001D988). What happens after you run the script?</div>
	<div class="answer">
       I don't have IDAPython working. 
	</div>
</div>

<div class="question-container">
	<div class="question">20. With the cursor in the same location, how do you turn this data into a single string?</div>
	<div class="answer">
       If you press A you can redefine this as a whole string. But it's important to do that after the string decryption, given that the null byte termination must be decrypted.
	</div>
</div>

<div class="question-container">
	<div class="question">21. Open the script with a text editor. How does it work?</div>
	<div class="answer">
        The code is the following:<br>
        <pre class="brush: py;">
        sea = ScreenEA()

        for i in range(0x00,0x50):
            b = Byte(sea+i)
            decoded_byte = b ^ 0x55
            PatchByte(sea+i,decoded_byte)
        </pre>    
        It's easy to guess that what the script does is to xor each byte in a range of 0x50 from the point in which we are with the 0x55 byte and pathches the binary with the resulting value of that operation.<br>
        <br>
        By the way, r2 let's you write scripts using all their functionalities (in a fucking huge number of languages!).
	</div>
</div>




<!-- Finally, to actually run the highlighter, you need to include this JS on your page -->
<script type="text/javascript">
	SyntaxHighlighter.defaults['smart-tabs'] = true;
	SyntaxHighlighter.defaults['highlight'] = [0, 0];
	SyntaxHighlighter.defaults['toolbar'] = false;
    SyntaxHighlighter.all()
</script>

</body>
</html>
