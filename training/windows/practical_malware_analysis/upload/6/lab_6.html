<!DOCTYPE HTML>

<html>
<head>
	<meta charset="utf-8">
	<!-- Include required JS files -->
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/shCore.js"></script>
	<!-- At least one brush -->
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/langs/shBrushPython.js"></script>
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/langs/shBrushNasm8086.js"></script>
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/langs/shBrushCpp.js"></script>
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/langs/shBrushBash.js"></script>
	<script type="text/javascript" src="../template/syntaxhighlighter_3.0.83/js/langs/shBrushDiff.js"></script>
	<!-- Include *at least* the core style and default theme -->
	<link href="../template/syntaxhighlighter_3.0.83/css/shCore.css" rel="stylesheet" type="text/css" />
	<link href="../template/syntaxhighlighter_3.0.83/css/shThemeDefault.css" rel="stylesheet" type="text/css" />
	<!-- My styles -->
	<link href="../template/css/my_styles.css" rel="stylesheet" type="text/css" />
</head>

<body>

<h1>LAB 6-1</h1>
<h3>In this lab, you will analyze the malware found in the file Lab06-01.exe. Radare2 and IDA Pro will be used whenever it's suitable.</h3>

<div class="question-container">
	<div class="question">1. What is the major code construct found in the only subroutine called by main?</div>
	<div class="answer">
        Analyzing the function with r2 we get the following code:<br>        
        <br>
        <img class="centered_img" src="img/6-1.1.1.png"/>
        <br>
        As can be seen, improvements to r2 have been implemented! Now you can read the string values in the disassembly view.<br>
        If we analyze it, we can see that this code is somewhat equivalent to:<br>
        <pre class="brush: py;">
        ret = WININET.InternetGetConnectedState(0, 0, ecx)
        if (ret == 0):
            0x40105F(0x407030)
            return 0
        else:
            0x40105F(0x407048)
            return 1
        </pre>
        If you check the arguments for each function, you can see that they are pointing to different strings:<br>
        <br>
        <img class="centered_img" src="img/6-1.1.2.png"/>
        <br>
	</div>
</div>

<div class="question-container">
    <div class="question">2. What is the subroutine located at 0x40105F?</div>
	<div class="answer">
        Seeking to that address (s 0x40105F) we find the following code:<br>
        <br>
        <img class="centered_img" src="img/6-1.2.1.png"/>
        <br>
        With IDA Pro we'd get this disassembly:<br>
        <br>
        <img class="centered_img" src="img/6-1.2.2.png"/>
        <br>
        With IDA Pro we get some more info, for example, the name of 2 out of 3 functions. <br>
        So we know that first a call to __stbuf function is made with, probably, 3 parameters (the three pushes). It seems that one of the parameters is a reference to a file. <br>
        Then, another function is called. This function seems to have three parameters too, the 2 parameters of the function we are analyzing and the previous reference to the file.<br>
        Finally, the third function (__ftbuf) is called with two parameters. The reference to the file and the result of the first function call (__stbuf).<br>
        <br>
        On the internet, there aren't many references to __stbuf() or __ftbuf() so it's hard to know what they do.<br>
        <br>
        Another approach is to look at the xrefs. With r2, clicking 'x', the cross references are listed as can be seen in the image:<br>
        <br>
        <img class="centered_img" src="img/6-1.2.3.png"/>
        <br>
        By clicking 0 and 1 we can go to the places where the functions are called:<br>
        <br>
        <img class="centered_img" src="img/6-1.2.3.png"/>
        <br>
        Once you look at one cross-reference you can click "u" to go to the previous analyzed function and go to the other xref. We get this results:<br>
        <br>
        <img class="centered_img" src="img/6-1.2.4.png"/>
        <br>
        <img class="centered_img" src="img/6-1.2.5.png"/>
        <br>
        After seeing this, we could infer that the function located to 0x40105F is, in fact, printf().
	</div>
</div>

<div class="question-container">
	<div class="question">3. What is the purpose of this program?</div>
	<div class="answer">
        To statically identify what this program does, it's a bit hardcore to analyze if from start to end, so we'll analyze what functions are imported, what strings, etc.<br>
        With r2 we can get all this information and more with the "ia" command, given that the output is too long we can analyze it separately.<br>
        <br>
        <img class="centered_img" src="img/6-1.3.1.png"/>
        <br>
        As we can see, only two libraries are used. One of them gives internet capabilities to the binary.<br>
        <br>
        <img class="centered_img" src="img/6-1.3.2.png"/>
        <br>
        With "ii" we can see all the imported functions. Some interesting functions are the following:<br>
        <ul style="list-style-type:none">
            <li>WININET.dll_InternetGetConnectedState</li>
            <li>KERNEL32.dll_GetCommandLineA</li>
            <li>KERNEL32.dll_GetVersion</li>
            <li>KERNEL32.dll_GetCurrentProcess</li>
            <li>KERNEL32.dll_GetModuleFileNameA</li>
            <li>KERNEL32.dll_GetEnvironmentStrings</li>
            <li>KERNEL32.dll_GetModuleHandleA</li>
            <li>KERNEL32.dll_GetEnvironmentVariableA</li>
            <li>KERNEL32.dll_GetProcAddress</li>
            <li>KERNEL32.dll_WriteFile</li>
            <li>KERNEL32.dll_LoadLibraryA</li>
        </ul>
        And finally with "iz" or "izz" we get the strings:<br>
        <br>
        <img class="centered_img" src="img/6-1.3.3.png"/>
        <br>
        It seems that there aren't interesting strings. Maybe the most important is the "user32.dll" that might indicate that this DLL would be loaded via LoadLibrary().
        <br>
        <br>
        After getting all that information we can infer almost nothing! So we'll have to analyze the binary itself.<br>
        <br>
        First of all, in order to analyze the code, we should go to the main function. With IDA Pro is as easy as opening the binary. With r2 you will have to look at the disassembly from the entry point of the binary and locate the main function. It is in 0x00401040.<br>
        <br>
        <img class="centered_img" src="img/6-1.3.4.png"/>
        <br>
        The only call in that code portion is to 0x00401000, so by clicking "1" we can analyze it.<br>
        <br>
        <img class="centered_img" src="img/6-1.3.5.png"/>
        <br>
        In this code, we only have a call to reloc.WININET.dll_InternetGetConnectedState_176 and to fcn.0040105f, that we've already defined as being printf(). Therefore, the only thing that this code does is to check whether the host has internet connection.
	</div>
</div>

<h1>LAB 6-2</h1>
<h3>Analyze the malware found in the file Lab06-02.exe.</h3>

<div class="question-container">
	<div class="question">1. What operation does the first subroutine called by main perform?</div>
	<div class="answer">
        Right now, r2 doesn't detect the main function address, so to not waste some time we open the binary with IDA Pro and it directly places us at main address at 0x00401130. So we can use r2 and seek to that address by "s 0x00401130", then we press "V" to go to "Visual Mode" and finally we press "p" one time to go to the disassembly view. We get this:<br>
        <br>
        <img class="centered_img" src="img/6-2.1.1.png"/>
        <br>
        To analyze the first function we should click "1". It' weird that the name shown is "section..text" instead of "fcn.00401000", it might be because there is where section .text start, let's check it by getting out of disassembly view ("q") and executing "iS":<br>
        <br>
        <img class="centered_img" src="img/6-2.1.2.png"/>
        <br>
        Indeed, that's what happened. Let's go on. Click "V" again.<br>
        <br>
        <img class="centered_img" src="img/6-2.1.3.png"/>
        <br>
        We have the same code that in the previous question. Wha this code does is check if there's internet connection.
	</div>
</div>

<div class="question-container">
	<div class="question">2. What is the subroutine located at 0x40117F?</div>
	<div class="answer">
        We seek to 0x40117F by pressing ":" to insert command and "s 0x40117F":<br>
        <br>
        <img class="centered_img" src="img/6-2.2.1.png"/>
        <br>
        We have the same structure as in the printf function analyzed in the previous question. Analyzing it with IDA Pro might be easier because it might could identify the three functions. Let's look at the cross references to check if the parameter to this functions is a string. Click "x" to see xrefs and "1" to go to the first and unique xref. Then use "k" to move up an see if there's a push before the call:<br> 
        <br>
        <img class="centered_img" src="img/6-2.2.2.png"/>
        <br>
        We have two pushes and one of them pushes an static address. It seems that r2 does not identify that as an string, but let's look at it using "px@0x407110":<br>
        <br>
        <img class="centered_img" src="img/6-2.2.3.png"/>
        <br>
        There we have our string. The function must probably be printf, so let's rename it. To this end we will use the "afn" command. If we execute "afn printf 0x40117F" the function will be renamed and we will see the calls to that address as "call printf":<br>
        <br>
        <img class="centered_img" src="img/6-2.2.4.png"/>
        <br>
	</div>
</div>

<div class="question-container">
	<div class="question">3. What does the second subroutine called by main do?</div>
	<div class="answer">
        One way to easily identify an ANSI C main() function is to look for calls inside the entry point function. There you can look at calls that previously have three pushes (for argc, argv and env parameters). This call would be probably more at the end of the function than at the beginning. In Lab06-02.exe you can find this call at 0x0040125f, calling to 0x00401130 as you can see in the following image:<br>
        <br>
        <img class="centered_img" src="img/6-2.3.1.png"/>
        <br>
        If you follow this call (pressing 9) you will see that the second call in this function is to 0x401040, if we follow it we'll see the following code:<br>    
        <br>
        <img class="centered_img" src="img/6-2.3.2.png"/>
        <br>
        As you can see, r2 has improved a lot since the last time we worked with it. It's thanks to their contributors that work in a fast pace.<br>
        The first part of the code makes a query to "http://www.practicalmalwareanalysis.com/cc.htm" using the WININET.InternetOpenUrlA() function. If the URL can be opened, the webpage is read with the WININET.InternetReadFile() function. This function has the following signature:<br>
        <pre class="brush: cpp;">
            BOOL InternetReadFile(
                _In_   HINTERNET hFile,
                _Out_  LPVOID lpBuffer,
                _In_   DWORD dwNumberOfBytesToRead,
                _Out_  LPDWORD lpdwNumberOfBytesRead
            );
        </pre>
        So we know that 0x200 (from the push 0x200 just before the call to the function) is the number of bytes that will be read.<br>
        We also know that the data read will be saved in the lpBuffer variable that in our case will be a pointer to the data stored in [ebp-0x210] (in a local variable).
        <br>
        The second part of the code is the following: <br>
        <br>
        <img class="centered_img" src="img/6-2.3.3.png"/>
        <br>
        If the InternetReadFile() function worked correctly, the first instruction to be executed would be "movsx ecx, byte [ebp - 0x210]". This instruction stands for "Move with sign extend" and means that the contents of the origin operand ([ebp - 0x210], what we previously read from the website) will be moved to the destiny operand (ecx) and the sign of the destiny operand will be extended. So if the sign is a 0 (what will happen) the ecx register will be filled with 0s plus the value (one byte in x86) in [ebp-0x210].<br>
        <br>
        Then we have a lot of 'compares and jumps'. All the jumps go to a "push <addr> + call func" instructions. The <addr> points to the string "Error 2.3: Fail to get command." that is past as a parameter for the function located in 0x0040117f. This code construct is a series of ifs that compare the first 4 bytes of the read bytes with '&lt;!--'. If any of the independent ifs fails, the comparison ends and a failure is reported by calling the function at 0x0040117f, if the comparisons go well, the function is exited without errors.<br>
        Finally, the byte after the '&lt;!--' is moved to register eax, so it will be what it's returned once the function ends.<br>
        <br>
        So to sum up, the analyzed function makes a query to a website in order to receive commands to know how to proceed. In order to read those commands the file readed from the server must start with '&lt;!--' (an HTML comment).
	</div>
</div>

<div class="question-container">
	<div class="question">4. What type of code construct is used in this subroutine?</div>
	<div class="answer">
       The code construct used in this subroutine is an string or, in C context, an array. This array is compared character to character using a set of ifs.
	</div>
</div>

<div class="question-container">
	<div class="question">5. Are there any network-based indicators for this program?</div>
	<div class="answer">
        Aside from the URL queried as seen in question 3, we can also indentify other network based indicators by looking for the binary strings using the izz command:<br>
        <br>
        <img class="centered_img" src="img/6-2.5.1.png"/>
        <br>
        We can see the "Internet Explorer 7.5/pma" that most probably would be used as User-Agent.<br>
        <br>
        More indicators could be gotten if the malware was run to, for example, get network signatures (bytes sent through the network), but this is not the purpose of the static reverse engineering chapter.
	</div>
</div>

<div class="question-container">
    <div class="question">6. What is the purpose of this malware?</div>
	<div class="answer">
        The malware has been analyzed in the previous questions. The only that remains to analyze is what happens once we return from the previusly mentioned function.<br>
        So, after the function ends, the return value is checked. If it's NULL, the malware exits the main function returning 0, but if it isn't a call to fcn.0040117f is done and afterwards we have another call to [section..rdata]. Let's analyze the first call.<br>
        <br>
        We have already seen many calls to 0x0040117f. If we checks the parameters passed to this function we can get that we have an string as shown in the following image:<br>
        <br>
        <img class="centered_img" src="img/6-2.6.1.png"/>
        <br>
        In the previous questions of this section we already defined this function as a printf() (go to question 2), but it lost its name because this analysis has been done after exiting r2 without saving changes. So we can rename it again with "afn printf 0x40117F".<br>
        The second parameter of the printf function (corresponding to the %c format string value) is ecx, that has stored the value of the local variable at [ebp-0x8] that is, in fact, the value returned from the previous function: the command to execute.<br>
        <br>
        If we analyze the second call, we can see that it calls the address of [section..rdata], if we check what we have there we will see this:<br>
        <br>
        <img class="centered_img" src="img/6-2.6.2.png"/>
        <br>
        In that address we have the relocation definition of the KERNEL32.Sleep() function. We see that the parameter setted before the call is "push 0xea60", so the sleep call will wait for 0xEA60 milliseconds (60 seconds). The problem with the sleep() function name has happened because a minor bug that it's been reported to r2 mantainers so sure it will be soon fixed!<br>
        Then the program will finish its execution.
	</div>
</div>

<h1>LAB 6-3</h1>
<h3>Analyze the malware found in the file Lab06-03.exe.</h3>

<div class="question-container">
	<div class="question"> 1. Compare the calls in main to Lab-6-2's main method. What is the new function called from main?</div>
	<div class="answer">
        With the r2 framework we have several ways to know this. The first and the most obvious would be to open the two binaries with r2 and manually analyze them. Nevertheless, we are lucky and thr r2 framework gives us some other tools to speed up the process.<br>
        <br>
        We can use the tool called radiff2. This tool is focused in finding out differences between two files. In our case we want to compare the main function that, as we know, it is located at the 0x401130 address (at least in Lab06-02.exe). So our first step will be to check if there are differences in that function between the two binaries:<br>
        <pre class="brush: bash;">
            $ radiff2 -C  Lab06-02.exe Lab06-03.exe | grep 401130
                   fcn.00401130  0x401130 | UNMATCH  (0.731959) | 0x401210  fcn.00401210
        </pre>        
        We get some interesting information with this command. The first one is that function at address 0x401130 in Lab06-02.exe corresponds to function at address 0x401210 in Lab06-03.exe. Moreover, this command tells us that those two function are not equal. Knowing this we can start to analyze them, manually or still using radiff2.<br>
        <br>
        With the -g parameter we can specify to radiff2 that it only compares one specific function, specifying it by name or by address. Then we can open the resulting dot file using xdot (apte-get install xdot) to check the differences:<br>
        <pre class="brush: bash;">
            $ radiff2 -g 0x401130 Lab06-02.exe Lab06-03.exe > diff_2to3.dot
            $ radiff2 -g 0x401210 Lab06-03.exe Lab06-02.exe > diff_3to2.dot
            $ xdot diff_2to3.dot &
            [1] 17199
            $ xdot diff_3to2.dot &
            [2] 17206
        </pre>
        This will open two graphs as the following:<br>
        <br>
        <img class="centered_img" src="img/6-3.1.1.png"/>
        <br>
        If we analyze the graphs we can see that gray areas have the same code. In the yellow areas only change the addresses of the jumps, but all the remaining code is the same. Finally, in red areas we have some major differences not only in simple addresses but in code length. With the following image we can better compare them:<br> 
        <br>
        <img class="centered_img" src="img/6-3.1.2.png"/>
        <br>
        After analyzing it, we can see that some code was added to the red area. Where in Lab06-02.exe we have the call to sleep() (shown as a call to section..rdata) now we have the following code:<br>
        <pre class="brush: asm;">
            0x0040124e    8b550c       mov edx, dword [ebp + 0xc]        ; [0xc:4]=0xffff
            0x00401251    8b02         mov eax, dword [edx]
            0x00401253    50           push eax
            0x00401254    8a4df8       mov cl, byte [ebp-local_8]
            0x00401257    51           push ecx
            0x00401258    e8d3feffff   call 0x401130                    ;[7]
            0x00401130      (unk, unk) ; section..text+304
            0x0040125d    83c408       add esp, 8
        </pre>
        So the new function called from main is to address 0x401130. Just as a curiosity, this address is the same as the main address of Lab06-02.exe. We will have to analyze if there's any relation with that.<br>
        <br>
        <br>
        <p class="red">Extra:</p> Now that we are working with bindiffing, we will also see other capabilities of radiff2. <br>
        <br>
        For example, radiff2 could give use an idea about how different are binaries by using the -s option:<br>
        <pre class="brush: bash;">
            $ radiff2 -s Lab06-02.exe Lab06-03.exe
            similarity: 0.94
            distance: 2381
        </pre>
        We can see that this to binaries are similar at a 94% rate. Their distance is computed using this <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">theory</a>, so I think it should denote the differences in bytes (deletions, additions, substitutions) between the two binaries.<br>
        <br>
        With the -c option we can check the number of differences of the two binaries. <br>
        <pre class="brush: bash;">
            $ radiff2 -c Lab06-02.exe Lab06-03.exe
            1154
        </pre>
        As we can see the number of differences is lower than the distance value of the previous command. It might be because the -c option only checks substitutions, but I'm not sure about it.<br>
        <br>
        Finally, there's another way to compare two binaries from an specific offset using r2. I have not found a way to compare them showing assembler instructions but making a hexdump, nevertheless it's worth knowing how to do this in case someone finds a way to show asm code.<br>
        The idea is to load two binaries in r2 using the "o" option, then we will seek to the address of the binary we opened with r2 and finally we will use the cc option to compare them. The following image will help you understand:<br>
        <br>
        <img class="centered_img" src="img/6-3.1.3.png"/>
        <br>
        You can see that we have loaded the binary with the "-n" option. In the shell command and inside r2 to load the second binary. This option is used to load binaries without taking into account the load base address of the binary and without loading its symbols.<br>
        With the "o" option we load a second binary in the same address space of the first one. For this reason we specify an offset (0x10000000, be careful if you are not in x64) so that the two binary contents don't overlap in memory (if so, r2 would warn us when listing loaded binaries with the "o" option alone).<br>
        <br>
        Given that we have used the "n" option to load binaries, we don't have symbols loaded. For this reason we use rabin2 from the outside of the r2 shell (using the "!") to know which is the base address of the binaries. In our case we can see it is 0x400000 (vaddr - paddr). This means that we have to substract this value from the addresses we previously used (0x401130 and 0x401210). The last thing to understand is that given that we have loaded the second binary in the a certain offset (0x10000000) we have to add this value to the address we want to diff from the second binary.<br>   
        Finally, as shown in the image, we have a hex diffing. Equal bytes are shown in green, while differences are shown in red. The comparison takes a 'blocksize' number of bytes, so we could modify the blocksize variable using the "b &lt;blocksize&gt;" command. Its default value is 0x100.
        <br>
        <br>
        <p class="red">Moar extra:</p> Pancake (r2 creator and main developer) added to r2 the capability of bindiffing as disassembly in Visual Mode through the new options ccd and cud. It was implemented just when the need of them were mentioned... The day after, it was done. Amazing!<br>
        <br>
        So now, instead of using the "cc" command you can use "ccd" to see an assembler bindiff side by side, in two columns. This view is really useful when you want to see the differences between small portions of code. Instead of generating graphical diagrams and all that stuff you can have a grasp of what has changed directly from the shell.<br>
        <br>
        <img class="centered_img" src="img/6-3.1.4.png"/>
        <br>
        Finally, if you don't like the side by side diff, you can use the typical unified view:<br>
        <br>
        <img class="centered_img" src="img/6-3.1.5.png"/>
        <br>
        At this point, we've done a good overview of the capabilities that r2 gives us to bindiff binaries.
	</div>
</div>

<div class="question-container">
	<div class="question">2. What parameters does this new function takes?</div>
	<div class="answer">
        
	</div>
</div>

<div class="question-container">
	<div class="question">3. What major code construct does this funcion contain?</div>
	<div class="answer">
        
	</div>
</div>

<div class="question-container">
	<div class="question">4. What can this function do?</div>
	<div class="answer">
        
	</div>
</div>

<div class="question-container">
	<div class="question">5. Are there any host-based indicators for this malware?</div>
	<div class="answer">
        
	</div>
</div>

<div class="question-container">
	<div class="question">6. What is the purpose of this malware?</div>
	<div class="answer">
        
	</div>
</div>

<h1>LAB 6-4</h1>
<h3>Analyze the malware found in the file Lab06-04.exe.</h3>

<div class="question-container">
	<div class="question">1. What is the difference between the calls made from the main method in Labs 6-3 and 6-4?</div>
	<div class="answer">
        
	</div>
</div>

<div class="question-container">
	<div class="question">2. What new code construct has been added to main?</div>
	<div class="answer">
        
	</div>
</div>

<div class="question-container">
	<div class="question">3. What is the difference between this lab's parse HTML function and those of the previous labs?</div>
	<div class="answer">
        
	</div>
</div>

<div class="question-container">
	<div class="question">4. How long will this program run? (Assume that it is connected to the internet)</div>
	<div class="answer">
        
	</div>
</div>

<div class="question-container">
	<div class="question">5. Are there any new network-based indicators for this malware?</div>
	<div class="answer">
        
	</div>
</div>

<div class="question-container">
	<div class="question">6. What is the purpose of this malware?</div>
	<div class="answer">
        
	</div>
</div>




<!-- Finally, to actually run the highlighter, you need to include this JS on your page -->
<script type="text/javascript">
	SyntaxHighlighter.defaults['smart-tabs'] = true;
	SyntaxHighlighter.defaults['highlight'] = [0, 0];
	SyntaxHighlighter.defaults['toolbar'] = false;
    SyntaxHighlighter.all()
</script>

</body>
</html>
